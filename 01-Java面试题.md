# 欢迎Java基础

## 1.  ArrayList 和 Vector 的区别  ##

1. 同步性：
Vector 是线程安全的，也就是说是它的方法之间是线程同步的，而 ArrayList 是线程序不安全的，它的方法之间是线程不同步的。Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差 
2. 数据增长：
 ArrayList 与 Vector 都有一个初始的容量大小，Vector 默认增长为原来两倍，而 ArrayList 的增长策略在文档中没有明确规定 （从源代码看到的是增长为原来的 `1.5` 倍）

## 2. 什么是 java 序列化，如何实现序列化，如何实现 java 序列化？或者请解释序列化？或者请解释 Serializable 接口的作用接口的作用 ##

 将一个 java 对象变成字节流的形式传出去或者从一个字节流中恢复成一个 java对象。

jre 本身就提供了这种支持，我们可以调用 OutputStream 的 writeObject 方法来做，如果要让 java 帮我们做，要被传输的对象必须**实现 serializable 接口。**

反序列化步骤：步骤一：创建一个ObjectInputStream输入流；步骤二：调用jectInputStream对象的readObject()得到序列化的对象

其中没有需要实现的方法， **implements Serializable只是为了标注该对象是可被序列化的。**

**Externalizable：强制自定义序列化：**通过实现Externalizable接口，必须实现writeExternal、readExternal方法。

## 3. 堆和栈的区别 ##

java 的内存分为两类，一类是栈内存，一类是堆内存。
1. 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间， 用于存储这个方法内部的局部变量， 当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。
2. 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用 new创建的对象都放在堆里，所以，它不会随方法的结束而消失。方法中的局部变量使用 final修饰后，放在堆中，而不是栈中

## 4.  解释一下什么是  servlet ##

 Servlet 是一种独立于平台和协议的服务器端的 Java 技术，可以用来生成动态的 Web 页面。与传统的 CGI（计算机图形接口）和许多其他类似 CGI 技术相比，Servlet 具有更好的可移植性、更强大的功能，更少的投资，更高的效率，更好的安全性等特点。Servlet 是使用 Java Servlet 应用程序接口（API）及相关类和方法的 Java 程序。Java 语言能够实现的功能，Servlet 基本上都能实现（除了图形界面之外）。
 **Servlet 主要用于处理客户端传来的 Http 请求，并返回一个响应。**

## 5.  说一说 一说 Servlet 的生命周期 ##

servlet 有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由 javax.servlet.Servlet 接口的 init,service 和 destroy 方法表达。Servlet 被服务器实例化后，容器运行其 init 方法，请求到达时运行其 service 方法，service方法自动派遣运行与请求对应的 doXXX 方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其 destroy 方法。web 容器加载 servlet，生命周期开始。通过调用 servlet 的 init()方法进行 servlet 的初始化。通过调用 service()方法实现，根据请求的不同调用不同的 do***()方法。结束服务，web 容器调用 servlet 的 destroy()方法。

## 6. 使用 final 关键字修饰 关键字修饰一个变量时，是引用不能变，还是引用的对象不能变 一个变量时，是引用不能变，还是引用的对象不能变 ##
 使用 final 关键字修饰一个变量时，是指引用变量不能变, 引用变量所指向的对象中的内容可以变

## 7. hashCode 方法的作用方法的作用 ##
  如果两个对象相同，那么它们的 hashCode 值一定要相同；
  如果两个对象的 hashCode 相同，它们并不一定相同

## 8. abstract class 和 interface 有什么区别 ##
1. 抽象类可以有构造方法，接口中不能有构造方法。
2. 抽象类中可以有普通成员变量，接口中没有普通成员变量
3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
4. 抽象类中的抽象方法的访问类型可以是 public， protected 和 （默认类型,虽然 eclipse 下不报错，但应该也不行），但接口抽象方法只能是 public 类型的，并且默认即为 public abstract类型。
5. 抽象类中可以包含静态方法，接口中不能包含静态方法
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意， 但接口中定义的变量只能是 public static final 类型， 并且默认即为 public static final 类型。
7. 一个类可以实现多个接口，但只能继承一个抽象类。

## 9. final, finally, finalize 的区别。 ##

 1. final: 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。内部类要访问局部变量，局部变量必须定义成 final 类型，例如，一段代码……
 2. finally：是异常处理语句结构的一部分，是异常的统一出口,表示总是执行。
 3. finalize：是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。JVM 不保证此方法总被调用.

## 10. Hashset和TreeSet的区别 ##
 1. HashSet是由一个hash表来实现的，因此它的元素是无序的
 2. TreeSet是由一个树形结构来实现的，它的元素是有序的，add() remove() contains()的复杂度是O(logn)

## 11. LinkedHashMap的实现原理 ##
> LinkedHashMap是基于HashMap实现的，它通过继承hashmap中的entry并添加两个属性Entry，before， after和header结合起来组成一个双向链表来实现插入顺序和访问顺序的排序。LinkedHashMap定义了排序模式AccessOder。 

## 12. Iterator和ListIterator的区别是什么 ##
 1. Iterator可用来遍历Set和List集合，ListIterator只能用来遍历List
 2. Iterator只能是前向遍历， ListIterator可前向后向
 3. ListIterator实现了Iterator接口，并包含其他功能，如：增加元素，替换元素，获取前一个和后一个元素的索引

## 13. stop(), suspend()为何不推荐使用？
 1. 反对使用stop()是因为它不安全。它会解除所有现成获取的所有锁定，而且如果对象处于一种不连贯的状态，那么其他线程在那种状态检查和修改它们，很难监察处真正的问题
 2. suspend()方法容易发生死锁。调用suspend（）的时候，目标线程会停下来，但却仍然持有之前获得的锁定。此时其他任何线程都不能访问锁定的资源。

## 14. 简述sychronized和java.util.concurrent.Lock的异同 ##
 1. 主要相同点：Lock能完成sychronized所实现的所有功能
 2. 主要不同点：Lock有比sychronized更精确的线程语义和更好的性能。sychronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally中释放，它的tryLock方法可以以非阻塞的方式去获取锁

## 15. volatile 变量是什么？volatile 变量和 atomic 变量有什么不同？ ##
  1. volatile 则是保证了所修饰的变量的可见。因为 volatile 只是在保证了同一个变量在多线程中的可见性，所以它更多是用于修饰作为开关状态的变量，即 Boolean 类型的变量。 
 2. volatile 多用于修饰类似开关类型的变量、Atomic 多用于类似计数器相关的变量、其它多线程并发操作用 synchronized 关键字修饰。
 3. volatile 有两个功用： 
 -  这个变量不会在多个线程中存在复本，直接从内存读取。 
 -  这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。 

## 16. jdk8新特性 ##
1. Lambda表达式和函数式接口
2. 接口的默认方法和静态方法
3. 方法引用
4. 重复注解
5. 更好的类型推断
6. 拓宽注解的应用场景

## 17. object类有哪些方法 ##
| 方法名  | 返回类型 | 方法描述 |
| ------- | -------- | -------- |
| clone()   		| Object    | 创建并返回对象一个副本    |
| equals(Object obj)|boolean	|判断obj对象是否与此对象相等|
|hashCode()			|int		|返回该对象的散列码值|
| getClass()		|Class<?>	|返回此Object的运行时类|
|toString()			|String		|返回该对象的字符串表示|
|finalize()			|void		|当垃圾回收器确定不存在对该对象的更多引用是，由垃圾回收器调用此方法|
|notify()			|void		|唤醒在此对象监视器上等待的单个进程|
|notifyAll()		|void		|唤醒在此对象监视器上等待的所有进程|
|wait()				|void		|在其他线程调用此对象的notify()/notifyAll()方法前，使当前线程等待|
|wait(long timeout)	|void		|在其他线程调用此对象的notify()/notifyAll()方法前，或超过指定的时间量前，使当前线程等待|
|wait(long timeout,int nanos)	|void|在其他线程调用此对象的notify()/notifyAll()方法前，或超过指定时间量前，或其他某个线程中断当前线程前，是当前线程等待|

## 18. Java内存泄漏 ##

1. 静态集合类引起内存泄漏
> 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放

2. 当集合里面的对象属性被修改后，再调用remove()方法时不起作用。 
```
Person p1 = new Person("唐僧","pwd1",25);
Person p2 = new Person("孙悟空","pwd2",26);
Person p3 = new Person("猪八戒","pwd3",27);
set.add(p1);
set.add(p2);
set.add(p3);
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!
p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变
set.remove(p3); //此时remove不掉，造成内存泄漏
set.add(p3); //重新添加，居然添加成功
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!
```
3. 监听器
>在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会

4. 各种连接
>比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。

5. 内部类和外部模块的引用
>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。

6. 单例模式
不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏，考虑下面的例子：

	```
	class A{
	public A(){
		B.getInstance().setA(this);
	}
	....
	}
	//B类采用单例模式
	class B{
		private A a;
		private static B instance=new B();
		public B(){}
		public static B getInstance(){
			return instance;
		}
		public void setA(A a){
			this.a=a;
		}
		//getter...
	} 
	```

## 19. equals和hashCode方法的关系 ##

1.  x.equals(y) 返回 “true”，那么 hashCode() 必须相等 ；
2.   x.equals(y) 返回 “false”，那么 hashCode() 有可能相等，也有可能不等 
3. 如果 x 和 y 的 hashCode() 不相等，那么 x.equals(y) 一定返回 “false” ；
4.  一般来讲，equals 这个方法是给用户调用的，而 hashcode 方法一般用户不会去调用 ；
5.  当一个对象类型作为集合对象的元素时，那么这个对象应该拥有自己的equals()和hashCode()设计，而且要遵守前面所说的几个原则。

> 1. 两个对象相等，hashcode⼀定相等
> 2. 两个对象不等，hashcode不⼀定不等
> 3. hashcode相等，两个对象不⼀定相等
> 4. hashcode不等，两个对象⼀定不等

## 20. equals方法和==的区别 ##
对于关系操作符 ==：
>若操作数的类型是基本数据类型，则该关系操作符判断的是左右两边操作数的值是否相等
若操作数的类型是引用数据类型，则该关系操作符判断的是左右两边操作数的内存地址是否相同。也就是说，若此时返回true,则该操作符作用      的一定是同一个对象。

equals方法的作用
>初衷 ： 判断两个对象的 content 是否相同
很显然，在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。使用equals方法，内部实现分为三个步骤：先比较引用是否相同(是否为同一对象), 再判断类型是否一致（是否为同一类型）,最后比较内容是否一致

## 21. Error和Exception

1. Error（错误）
   定义：Error 类及其子类。程序中无法处理的错误，表示运行应用程序中出现了严重的错误。

   特点：此类错误一般表示代码运行时 JVM 出现问题。通常有 **Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError**：栈溢出错误。此类错误发生时，JVM 将终止线程。

   这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！

3. Exception（异常）
  程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。

  运行时异常
  定义：**RuntimeException** 类及其子类，表示 JVM 在运行期间可能出现的异常。

  特点：Java 编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既"没有通过throws声明抛出它"，也"没有用try-catch语句捕获它"，还是会编译通过。比如**NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常**。此类异常属于不受检异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。虽然 Java 编译器不会检查运行时异常，但是我们也可以通过 throws 进行声明抛出，也可以通过 try-catch 对它进行捕获处理。

## 22. throw 和 throws 的区别是什么

Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。

throws 关键字和 throw 关键字在使用上的几点区别如下：

1. throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。

2. throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。

## ArrayList和LinkedList

- HashSet底层使用了Hash表实现。无序。保证元素唯一性的原理：判断元素的hashCode值是否相同。如果相同，还会继续判断元素的equals方法，是否为true

- TreeSet底层使用了红黑树来实现。有序。保证元素唯一性是通过Comparable或者Comparator接口实现

## Java动态代理

代理类在程序运行时创建的代理方式被成为动态代理。

JDK动态代理主要涉及两个类：`java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler`

***

# HashMap、ConcurrentHashMap

### HaspMap添加操作和resize ###

### HaspMap为什么使用数组+链表？用LinkedList代替数组可以吗？

https://zhuanlan.zhihu.com/p/127147909

既然是可以的，为什么不用反而用数组。因为⽤数组效率最⾼！ 在HashMap中，定位节点的位置是利⽤元素的key的哈希值对数组长度取模得到。此时，我们已得到节点的位置。显然数组的查找效率⽐`LinkedList`⼤（底层是链表结构）。那`ArrayList`，底层也是数组，查找也快啊，为啥不⽤ArrayList? 因为采⽤基本数组结构，扩容机制可以⾃⼰定义，HashMap中数组扩容刚好是**2的次幂**，在做取模运算的效率⾼。 ⽽ArrayList的扩容机制是1.5倍扩容

## 讲一讲HashMap的get/put过程

> 知道HashMap的put元素的过程是什么样吗？
>
> 知道get过程是是什么样吗？
>
> 你还知道哪些的hash算法？
>
> 说一说String的hashcode的实现

### Put方法

1. 对key的hashCode()做hash运算，计算index;
2. 如果没碰撞直接放到bucket⾥；
3. 如果碰撞了，以链表的形式存在buckets后；
4. 如果碰撞导致链表过长(⼤于等于TREEIFY_THRESHOLD)，就把链表转换成红⿊树(JDK1.8中的改动)；
5. 如果节点已经存在就替换old value(保证key的唯⼀性)
6. 如果bucket满了(超过load factor*current capacity)，就要resize

在得到下标值以后，可以开始put值进入到数组+链表中，会有三种情况：

1. 数组的位置为空。
2. 数组的位置不为空，且面是链表的格式。
3. 数组的位置不为空，且下面是红黑树的格式。

同时 对于`Key` 和`Value` 也要经历一下步骤

- 通过 Key 散列获取到对于的Table；’
- 遍历Table 下的Node节点，做更新/添加操作；
- 扩容检测；

以上就是`HashMap`的Put操作

### resise方法

HashMap 的扩容实现机制是将老table数组中所有的Entry取出来，重新对其Hashcode做`Hash`散列到新的Table中，可以看到注解`Initializes or doubles table size.` resize表示的是对数组进行初始化或进行Double处理。

### get方法

1. 对key的hashCode()做hash运算，计算index;
2. 如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；
3. 如果有冲突，则通过key.equals(k)去查找对应的Entry;
4. 若为树，则在树中通过key.equals(k)查找，O(logn)；
5. 若为链表，则在链表中通过key.equals(k)查找，O(n)。

### HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么

Hashmap在并发环境下，可能出现的问题：

1. **多线程put时可能会导致get无限循环**，具体表现为CPU使用率100%；
   原因：在向HashMap put元素时，会检查HashMap的容量是否足够，如果不足，则会新建一个比原来容量大两倍的Hash表，然后把数组从老的Hash表中迁移到新的Hash表中，迁移的过程就是一个rehash()的过程，多个线程同时操作就有可能会形成循环链表，所以在使用get()时，就会出现Infinite Loop的情况
2. **多线程put时可能导致元素丢失** 原因：当多个线程同时执行addEntry(hash,key ,value,i)时，如果产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会发生元素覆盖丢失的情况

## hash冲突

- 拉链法 （HashMap使用的方法）
- 线性探测再散列法
- 二次探测再散列法
- 伪随机探测再散列法

# JVM面试题 #

## 内存模型以及分区，需要详细到每个区放什么。 ##
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区
1. **程序计数器(Program Counter Register)**

	一块较小的内存空间，它是**当前线程所执行的字节码的行号指示器**，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。

2. **Java虚拟机栈（Java Virtual Machine Stacks）**

	该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，**栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构**。对于执行引擎来讲，**活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧**，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。**栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。**在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

3. **本地方法栈（Native Method Stacks）**

	该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

4. **Java堆（Java Heap）**

	Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎**所有的对象实例和数组都在这类分配内存**。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

	根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。

5. **方法区（Method Area）**

	方法区也是各个线程共享的内存区域，**它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 几种常用的内存调试工具：jmap、jstack、jconsole ##
1. **jmap**（linux下特有，也是很常用的一个命令）观察运行中的jvm物理内存的占用情况。 
   参数如下： 
   
   -heap：打印jvm heap的情况 
   
   -histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。 
   
   -histo：live ：同上，但是只答应存活对象的情况 
   
   permstat：打印permanent generation heap情况
   
2. **jstack**可以观察到jvm中当前所有线程的运行情况和线程当前状态 

3. **jconsole**一个图形化界面，可以观察到java进程的gc，class，内存等信息 

4. **jstat** 最后要重点介绍下这个命令。这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息 
   具体参数如下： 

   -class：统计class loader行为信息 

   -compile：统计编译行为信息 

   -gc：统计jdk gc时heap信息 

   -gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况 

   -gccause：统计gc的情况，（同-gcutil）和引起gc的事件 

   -gcnew：统计gc时，新生代的情况 

   -gcnewcapacity：统计gc时，新生代heap容量 

   -gcold：统计gc时，老年区的情况 

   -gcoldcapacity：统计gc时，老年区heap容量 

   -gcpermcapacity：统计gc时，permanent区heap容量 

   -gcutil：统计gc时，heap情况 

   -printcompilation：不知道干什么的，一直没用过。

## 类加载的五个过程：加载、验证、准备、解析、初始化。 ##
它的整个生命周期包括**加载、验证、准备、解析、初始化、使用、卸载**。
>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段

1. **加载**(Loading)阶段是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：
> 1. 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
> 3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

2. **验证**是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

3. **准备阶段**是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

4. **解析阶段**是虚拟机将常量池内的符号引用替换为直接引用的过程。
5. 类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

##  双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。##
1. **启动类加载器**，负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即时放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用。
2. **扩展类加载器**：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该类加载器。
3. **应用程序类加载器**：负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，也是默认的类加载器。 三种加载器的关系：启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器。

这种关系即为类加载器的双亲委派模型。其要求除启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是用组合的方式来复用父类的代码。

双亲委派模型的工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。

实现：在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

## 描述一下 JVM 加载 Class 文件的原理机制 ##
- Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成 的 .class 文件按照需求和一定的规则加载到内存中，并组织成为 一个完整的 Java 应用程序。 这个加载过程是由类加载器完成， 具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其**实质是把类文件从硬盘读取到内存中。**
- 类的加载方式分为隐式加载和显示加载。 隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。 显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。 
- 类加载的主要步骤： 
```
• 装载。根据查找路径找到相应的 class 文件，然后导入。 
• 链接。链接又可分为 3 个小步： 
• 检查，检查待加载的 class 文件的正确性。 
• 准备，给类中的静态变量分配存储空间。 
• 解析，将符号引用转换为直接引用（这一步可选） 
• 初始化。对静态变量和静态代码块执行初始化工作。
```

# 多线程 #
## 线程间通讯方式

synchronized、notify、wait、volatile

lock、condition

## CAS

CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

## Synchronized 其原理是什么

 被 Synchronized 修饰过的程序块，在编译前后被编译器生成了monitorenter 和 monitorexit 两 个 字 节 码 指 令 。在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁: 如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁 的计数器 +1;当执行 monitorexit 指令时将锁计数器 -1;当计数器 为 0 时，锁就被释放了。如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一 个线程释放为止。

## Thread与Runable如何实现多线程 ##

**一种是继承Thread类**；**另一种是实现Runnable接口**。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。

实现Runnable接口相比继承Thread类有如下优势：
1. 可以避免由于Java的单继承特性而带来的局限
2. 增强程序的健壮性，代码能够被多个程序共享，代码与数据是独立的
3. 适合多个相同程序代码的线程区处理同一资源的情况

补充：Java 5以后创建线程还有第三种方式：**实现Callable接口**，该接口中的call方法可以在线程执行结束时产生一个返回值

## **Thread 类中的start() 和 run() 方法有什么区别**

start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程，new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

## Thread类中的yield方法有什么作用

Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

线程让步：如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：你的工作已经做得差不多了，可以让别的线程使用CPU了。这个暗示将通过调用yield()方法来做出（不过这只是一个暗示，没有任何机制保证它将会被采纳）。当调用yield()时，也是在建议具有相同优先级的其他线程可以运行。

yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！

## 什么是ThreadLocal变量

使用ThreadLocal维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。

ThreadLocal内部实现机制：

- 每个线程内部都会维护一个类似HashMap的对象，称为ThreadLocalMap，里边会包含若干了Entry（K-V键值对），相应的线程被称为这些Entry的属主线程
- Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象。Entry的作用是为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系
- Entry对Key的引用是弱引用；Entry对Value的引用是强引用。

## 守护线程与阻塞线程 ##
ava中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)

用户线程即运行在前台的线程，而守护线程是运行在后台的线程。 守护线程作用是为其他前台线程的运行提供便利服务，而且仅在普通、非守护线程仍然运行时才需要，比如垃圾回收线程就是一个守护线程。当VM检测仅剩一个守护线程，而用户线程都已经退出运行时，VM就会退出，因为如果没有了守护者，也就没有继续运行程序的必要了。如果有非守护线程仍然活着，VM就不会退出。

守护线程并非只有虚拟机内部提供，用户在编写程序时也可以自己设置守护线程。用户可以用Thread的setDaemon(true)方法设置当前线程为守护线程。
>虽然守护线程可能非常有用，但必须小心确保其它所有非守护线程消亡时，不会由于它的终止而产生任何危害。因为你不可能知道在所有的用户线程退出运行前，守护线程是否已经完成了预期的服务任务。一旦所有的用户线程退出了，虚拟机也就退出运行了。因此，不要再守护线程中执行业务逻辑操作(比如对数据的读写等)。

还有几点：

setDaemon(true)必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常。
在守护线程中产生的新线程也是守护线程
不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。

## AQS （AbstractQueuedSynchronizer）抽象队列同步器 ##

1. AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面
**AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。它包含了state变量、加锁线程、等待队列等并发中的核心组件。**
> AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock， Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。

2. AQS 原理

	**AQS核心思想**是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

	>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。


### AQS 对资源的共享方式 ###

1. **Exclusive（独占）**：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：
	公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
	非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
2. **Share（共享）**：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 

### CountDownLatch （倒计时器） ###
1. 某一线程在开始运行前等待n个线程执行完毕.个典型应用场景就是启动一个服务时，主线程需要**等待多个组件加载完毕**，之后再继续执行。
2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是**多个线程在某一时刻同时开始执行**

### CyclicBarrier(循环栅栏)

让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。
>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。

### CyclicBarrier和CountDownLatch的区别 ###
1. CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用

	> 1. CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)
	> 2. CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)

## ThreadPoolExecutor线程池参数

**corePoolSize：** 线程池核心线程数最大值

**maximumPoolSize：** 线程池最大线程数大小

**keepAliveTime：** 线程池中非核心线程空闲的存活时间大小

**unit：** 线程空闲存活时间单位

**workQueue：** 存放任务的阻塞队列

**threadFactory：** 用于设置创建线程的工厂，可以给创建的线程设置有意义的名字，可方便排查问题。

**handler：**  线城池的饱和策略事件，主要有四种类型。

1. 提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。
2. 如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。
3. 当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。
4. 如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。

## 几种常用的线程池

newFixedThreadPool (固定数目线程的线程池)

newCachedThreadPool(可缓存线程的线程池)

newSingleThreadExecutor(单线程的线程池)

newScheduledThreadPool(定时及周期执行的线程池)

# MySql #

## 1. B+树与二叉树区别，优点？为什么不用红黑树？ ##

1. 红黑树是一个平衡的二叉查找树。有以下几个性质：
> - 根节点和叶子节点都是黑色的（这里的叶子节点指的是普通的节点增加的一个黑色的空节点）。
> - 红色节点的子节点必须是黑色的，也就是不能有两个红色节点连续。
> - 从根节点到叶子节点的所有路径包含的黑色节点的个数是一致的。

2. 红黑树是二叉查找树（也就是每个节点的左子树<当前节点的值，右子树所有节点>=当前节点值），但不是严格意义上的平衡二叉树，因为平衡二叉树要求任何节点的左右子树高度差是<=1，红黑树根节点到叶子节点的最长路径会<=最短路径的两倍,所有他是大致意义上的平衡树。

3. 相比于AV树（也就是自平衡的二叉查找树，左右子树高度差不超过1），红黑树插入，删除效率更高。因为不需要保证绝对的平衡，任何不平衡需要的旋转次数不超过3次，即便在最坏的情况下，红黑树能够以O(log(N))的时间复杂度进行搜索、插入、删除操作。

##  2. 与红黑树的比较 ##

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：
1. 更少的查找次数
>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。
红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

2. 利用磁盘预读特性
> 为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。而B+数中存储的叶子节点在内存中是相邻的，这样可以读取会快一些。

3. 存储更多的索引节点
>B+树跟B树的区别就是B+是叶子节点存储数据，非叶子节点只存储索引项，B树是所有节点都存储数据，所以B+树的索引节点（非叶子节点）的大小<B树的索引节点，相同内存下，B+树可以容纳的索引节点更多。

## 3. 索引是什么 ##

索引可以让服务器快速定位到表的指定位置:
> 1. 大大减少了服务器需要扫描的数据量。
> 2. 帮助服务器避免排序带来的性能开销。
> 3. 将随机IO变成顺序IO。

## 4. 不设置MySQL主键会怎么样？ ##

如果没有设置主键，innodb会选择第一个非空唯一索引作为聚集索引。
如果没有设置主键，也没有合适的唯一索引，那么会生成一个隐藏的id作为索引的主键，这个值会随着插入而自增。
主键如果是自增的，那么插入数据的位置是已知的，而且不用移动已有数据。如果是非自增的，首先需要查找到要插入的位置，近似于随机查找，然后将后面的数据向后移动。

## 5. 聚集索引是什么？ ##

聚集索引与非聚集索引的最主要的区别是：叶节点是否存放一整行记录
> 1. 对于聚簇索引表来说（左图），表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，其他列，事务ID，回滚指针，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。
>2. 对于非聚簇索引表来说（右图），表数据和索引是分成两部分存储的，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+指向索引对应的记录的数据的指针。

## 3. 聚簇索引的优点 ##

1. 当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。
2. 当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

## 4. 聚簇索引的缺点 ##

1. **插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键。

2. **更新主键的代价很高**，**因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。

3. 二**级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**
二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。

4. **采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。

## 5. 联合索引是什么？ ##

联合索引就是多列索引，就是可以多个字段建立一个索引，并且是最左前缀匹配元素

## 6. 哪些情况需要建索引： ##

1. 主键，唯一索引
2. 经常用作查询条件的字段需要创建索引
3. 经常需要排序、分组和统计的字段需要建立索引
4. 查询中与其他表关联的字段，外键关系建立索引

## 7.哪些情况不要建索引？ ##

1. 表的记录太少，百万级以下的数据不需要创建索引
2. 经常增删改的表不需要创建索引
3. 数据重复且分布平均的字段不需要创建索引，如 true,false 之类。
4. 频发更新的字段不适合创建索引
5. where条件里用不到的字段不需要创建索引

##Join的工作流程是怎么样的，怎么进行优化？##
## 8. join的大概使用是怎么样的？ ##

>full outer join 会包含两个表不满足条件的行
left outer join 会包含左边的表不满足条件的行
right outer join 会包含右边的表不满足条件的行
inner join 就是只包含满足条件的行
cross join 从表A循环取出每一条记录去表B匹配，cross join 后面不能跟on，只能跟where

## 9. char类型与varchar类型的区别？ ##

char类型

> char类型是定长的，在内部存储时实际使用长度较短时会在右边用空格填充，所以插入的数据如果右边有空格会自动截断，因为没有办法知道是自带的还是填充的。
英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
适合每行数据的长度比较平均的情况，否则会造成存储空间的浪费。

varchar类型
>是不定长的，有一个字节用来存储长度(当长度大于255时，使用两个字节来存储长度)，内部存储时，使用多少长度，内存中就占用多少长度，不会有空余，所以比较节省空间。
varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节。
效率上其实varchar会好一点，其实网上没有比较详尽的测试，看一个博客对1000w的数据进行测试时，varchar会略高一点。

## 10. 索引的创建步骤是怎么样的？ ##

通过ALTER TABLE ADD/DROP或者CREATE/DROP INDEX 可以创建和删除索引。
``` 
//ALTER 命令可以为表增加主键索引，唯一性索引，普通索引
ALTER TABLE table_name add primary key (column_list) ;
ALTER TABLE table_name ADD INDEX index_name (column list);
ALTER TABLE table_name DROP INDEX index_name (column list);
//CREATE 命令可以为表增加唯一性索引，普通索引
CREATE index index_name on table_name (column_list);
DROP index index_name on table_name (column_list);
```

***




# HTTP #
##  ##

# Netty #

## Netty的特点 ##
1. 一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、UDP 和文件传输的支持 
2. 使用更高效的 socket 底层，对 epoll 空轮询引起的 cpu 占用飙升在内部进行了处理，避免了直接使用 NIO 的陷阱，简化了 NIO 的处理方式。 
3. 采用多种 decoder/encoder 支持，对 TCP 粘包/分包进行自动化处理 
4. 可使用接受/处理线程池，提高连接效率，对重连、心跳检测的简单支持 
4. 可配置 IO 线程数、TCP 参数， TCP 接收和发送缓冲区使用直接内存代替堆内存，通过内存池的方式循环利用 ByteBuf 
5. 通过引用计数器及时申请释放不再引用的对象，降低了 GC 频率 
6. 使用单线程串行化的方式，高效的 Reactor 线程模型 
6. 大量使用了 volitale、使用了 CAS 和原子类、线程安全类的使用、读写锁的使用

## Netty的线程模型 ##
Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。

## BIO、NIO 和 AIO 的区别 ##
**BIO**：一个连接一个线程，客户端有连接请求时服务器端就需要启动一个线程进行处理。线
程开销大。 
伪异步 IO：将请求连接放入线程池，一对多，但线程还是很宝贵的资源。 
**NIO**：一个请求一个线程，但客户端发送的连接请求都会注册到多路复用器上，多路复用
器轮询到连接有 I/O 请求时才启动一个线程进行处理。 
**AIO**：一个有效请求一个线程，客户端的 I/O 请求都是由 OS 先完成了再通知服务器应用去
启动线程进行处理，

NIO 的特点：事件驱动模型、单线程处理多任务、非阻塞 I/O，I/O 读写不再阻塞，而是返回 0、基于 block 的传输比基于流的传输更高效、更高级的 IO 函数 zero-copy、IO 多路复用大大提高了 Java 网络应用的可伸缩性和实用性。基于 Reactor 线程模型。

## TCP 粘包/拆包的原因及解决方法

TCP 粘包/分包的原因：应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写
入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现象；进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度>MSS 的时候将发生拆包 
以太网帧的 payload（净荷）大于 MTU（1500 字节）进行 ip 分片。

**解决方法** 

1. 消息定长：FixedLengthFrameDecoder 类 
2. 包尾增加特殊字符分割：行分隔符类：LineBasedFrameDecoder 或自定义分隔符类 ：DelimiterBasedFrameDecoder 
3. 将消息分为消息头和消息体：LengthFieldBasedFrameDecoder 类。分为有头部的拆包与粘包、长度字段在前且有头部的拆包与粘包、多扩展头部的拆包与粘包。

## 了解哪几种序列化协议

> 序列化（编码）是将对象序列化为二进制形式（字节数组） ，主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用） 、序列化的性能（CPU 资源占用） ；是否支持跨语言（异构系统的对接和开发语言切换） 。 

**XML**

> 优点：人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。

**JSON**

> 是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与 XML 相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比 XML 差、不适合性能要求为 ms 级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于 Web browser 的 Ajax 请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。 

**Fastjson**

> 采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前 java 语言中最快的 json 库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web 输出、Android 客户端 

**Thrift**

> 不仅是序列化协议，还是一个 RPC 框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如 HTTP） 、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的 RPC 解决方案 

**Avro**

>Hadoop 的一个子项目，解决了 JSON 的冗长和没有 IDL 的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用 RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在 Hadoop 中做 Hive、Pig 和 MapReduce的持久化数据格式。

## 如何选择序列化协议

1. 对于调试环境比较恶劣的场景，采用 JSON 或 XML 能够极大的提高调试效率，降低系统开发成本。 
2. 当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro 之间具有一定的竞争关系。
3. 对于 T 级别的数据的持久化应用场景，Protobuf 和 Avro 是首要选择。如果持久化后的数据存储在 hadoop 子项目里，Avro 会是更好的选择。 
4. 对于持久层非 Hadoop 项目，以静态类型语言为主的应用场景，Protobuf 会更符合静态类型语言工程师的开发习惯。由于 Avro 的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro 是更好的选择。
5. 如果需要提供一个完整的 RPC 解决方案，Thrift 是一个好的选择。
6. 如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，
   Protobuf 可以优先考虑。

## Netty 的高性能表现在哪些方面

1. 心跳，对服务端：会定时清除闲置会话 inactive(netty5)，对客户端:用来检测会话是否断开，是否重来，检测网络延迟，其中 idleStateHandler 类 用来检测会话状态 
2. 串行无锁化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。 
3. 可靠性，链路有效性检测：链路空闲检测机制，读/写空闲超时机制；内存保护机制：通过内存池重用 ByteBuf; ByteBuf 的解码保护；优雅停机：不再接收新消息、退出前的预处理操作、资源的释放操作。 
4. Netty 安全性：支持的安全协议：SSL V2 和 V3，TLS，SSL 单向认证、双向认证和第三方 CA认证。 
5. 高效并发编程的体现：volatile 的大量、正确使用；CAS 和原子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。IO 通信性能三原则：传输（AIO） 、协议（Http） 、线程（主从多线程） 
6. 流量整型的作用（变压器）：防止由于上下游网元性能不均衡导致下游网元被压垮，业务流中断；防止由于通信模块接受消息过快，后端业务线程处理不及时导致撑死问题。 
7. TCP 参数配置：SO_RCVBUF 和 SO_SNDBUF：通常建议值为 128K 或者 256K；SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法； 

## 设计模式

手写单例模式

```

```



# 待解决：

### 常用排序算法空间时间复杂度 ###

### 网络层的功能，子网掩码的用途 ###

### DNS服务器基本流程，DNS劫持是什么，DNS解析 ###

**DNS劫持**：就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。

2. 

### 为什么要反射？什么时候用？有什么缺点 ###

### **枚举Enumeration 和Iterator接口之间的差异是什么**

枚举是快迭代两倍，使用非常少的内存。枚举适合基本需求。但Iterator是更安全，因为它总是拒绝其他线程修改它正在迭代集合中的对象。

foreach循环**适用范围：**对于任何实现Iterable接口的容器都可以使用foreach循环。foreach语法的冒号后面可以有两种类型：一种是数组，另一种是是实现了Iterable接口的类。



### http1 2 3的区别具体说一下 ###

- [x] 1. 为什么要重写hashcode和equal（）？

