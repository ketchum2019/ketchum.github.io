## MySql优化

![image-20200717083711279](images\image-20200717083711279.png)

## 创建索引

单列索引值之普通索引

```mysql
CREATE INDEX index_name ON table(column(length));
ALTER TABLE table_name ADD INDEX index_name (column(length));
```

单列索引值之唯一索引

```mysql
CREATE UNIQUE INDEX index_name ON table(column(length));
ALTER TABLE table_name add unique index index_name (column(length));
```

单列索引值之唯一索引

```mysql
ALTER TABLE artical ADD INDEX index_name (title(50), time(10));
```

删除索引

```mysql
DROP INDEX index_name ON table
```

查看索引

```mysql
SHOW INDEX FROM table_name
```

聚簇索引：叶子节点保存索引和数据

非聚簇索引：叶子节点保存索引和指针地址

覆盖索引：辅助索引查询后，不需要回表查询为覆盖索引，其他需要二次回表查询

innodb必须要求表有主键，没有显示指定的话会自动生成一个隐含字段作为主键，类型为长整型

## 哪些情况需要创建索引

1. 主键自动创建唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 多表关联查询中，关联字段应该创建索引 on 两边都要创建索引
4. 查询中排序的字段应该创建索引
5. 频繁查找字段，覆盖索引
6. 查询中 统计或分组字段，应该创建索引

## 组合索引（联合索引）

遵循最左前缀原则

```mysql
ALTER TABLE 'table_name' ADD INDEX index_name(col1,col2,col3) 
```

## 锁

![image-20200717103432510](images\image-20200717103432510.png)

## MySQL常见的存储引擎有哪些

MySQL中最常见的存储引擎有InnoDB和MyISAM，它们的主要区别如下：

- MyISAM不支持事务；InnoDB是事务类型的存储引擎。
- MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。
- MyISAM引擎不支持外键；InnoDB支持外键。
- 对于count(*)查询来说MyISAM更有优势，因为其保存了行数。
- InnoDB是为处理巨大数据量时的最大性能设计的存储引擎。
- MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。

最主要的区别就是MyISAM表不支持事务、不支持行级锁、不支持外键。 InnoDB表支持事务、支持行级锁、支持外键。

## MySQL中where、group by、having关键字

- where子句用来筛选from子句中指定的操作所产生的的行
- group by 子句用来分组where子句的输出
- having子句用来从分组的结果中筛选行
- **having和where的区别：**
  - 语法类似，where搜索条件在进行分组操作之前应用；having搜索条件在进行分组操作之后应用
  - having可以包含聚合函数sum、avg、max等
  - having子句限制的是组，而不是行

## 有哪些数据库优化方面的经验?

1. 用PreparedStatement， 一般来说比Statement性能高：一个sql 发给服务器去执行，涉及步骤：语法检查、语义分析， 编译，缓存。
2. 有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。
3. 表中允许适当冗余，譬如，主题帖的回复数量和最后回复时间等
4. UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复数据且不需要排序时的话，那么就使用UNION ALL。 >>UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。 >1. 对重复结果的处理：UNION在进行表链接后会筛选掉重复的记录，Union All不会去除重复记录。 >2. 对排序的处理：Union将会按照字段的顺序进行排序；UNION ALL只是简单的将两个结果合并后就返回。

## Sql优化原则

