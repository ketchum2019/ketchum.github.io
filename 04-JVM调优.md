# JVM调优

## 1. 衡量垃圾收集器的指标

内存占用、吞吐量、延迟

## 2. 内存模型以及分区，需要详细到每个区放什么。 ##

JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区

1. **程序计数器(Program Counter Register)**

   一块较小的内存空间，它是**当前线程所执行的字节码的行号指示器**，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，分支、跳转、循环等基础功能都要依赖它来实现。每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，因此该区域是线程私有的。当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中么有规定任何OOM（内存溢出：OutOfMemoryError）情况的区域。

2. **Java虚拟机栈（Java Virtual Machine Stacks）**

   该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，**栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构**。对于执行引擎来讲，**活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧**，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。**栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。**在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

3. **本地方法栈（Native Method Stacks）**

   该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

4. **Java堆（Java Heap）**

   Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎**所有的对象实例和数组都在这类分配内存**。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

   根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。

5. **方法区（Method Area）**

   方法区也是各个线程共享的内存区域，**它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。**方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不存在永久代的概念。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 3. 几种常用的内存调试工具：jmap、jstack、jconsole ##

1. **jmap**（linux下特有，也是很常用的一个命令）观察运行中的jvm物理内存的占用情况。 
   参数如下： 

   -heap：打印jvm heap的情况 

   -histo：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。 

   -histo：live ：同上，但是只答应存活对象的情况 

   -permstat：打印permanent generation heap情况

2. **jstack**（linux下特有）可以观察到jvm中当前所有线程的运行情况和线程当前状态 jconsole一个图形化界面，可以观察到java进程的gc，class，内存等信息 

3. **jstat** 最后要重点介绍下这个命令。这是jdk命令中比较重要，也是相当实用的一个命令，可以观察到classloader，compiler，gc相关信息 
   具体参数如下： 

   -class：统计class loader行为信息 

   -compile：统计编译行为信息 

   -gc：统计jdk gc时heap信息 

   -gccapacity：统计不同的generations（不知道怎么翻译好，包括新生区，老年区，permanent区）相应的heap容量情况 

   -gccause：统计gc的情况，（同-gcutil）和引起gc的事件 

   -gcnew：统计gc时，新生代的情况 

   -gcnewcapacity：统计gc时，新生代heap容量 

   -gcold：统计gc时，老年区的情况 

   -gcoldcapacity：统计gc时，老年区heap容量 

   -gcpermcapacity：统计gc时，permanent区heap容量 

   -gcutil：统计gc时，heap情况 

   -printcompilation：不知道干什么的，一直没用过。
   
4. **jps：**主要用来输出JVM中运行的进程状态信息，一般使用jps命令来查看进程的状态信息，包括JVM启动参数等。

   ```
   -q：仅输出VM标识符，不包括``class` `name,jar name,arguments in main method
   -m：输出main method的参数
   -l：输出完全的包名，应用主类名，jar的完全路径名
   -v：输出jvm参数
   ```

## 4. 如何排查一个线上的服务异常

- 首先查看当前进程的JVM启动参数，查看内存设置是否存在明显问题。
- 查看GC日志，看GC频率和时间是否明显异常。
- 查看当前进程的状态信息top -Hp pid，包括线程个数等信息。
- jstack pid查看当前的线程状态，是否存在死锁等关键信息。
- jstat -gcutil pid查看当前进程的GC情况。
- jmap -heap pid查看当前进程的堆信息，包括使用的垃圾收集器等信息。
- 用jvisiual工具打开dump二进制文件，分析是什么对象导致了内存泄漏，定位到代码处，进行code review。

## 5. 类加载的五个过程：加载、验证、准备、解析、初始化。 ##

它的整个生命周期包括**加载、验证、准备、解析、初始化、使用、卸载**。

>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段

1. **加载**(Loading)阶段是“类加载”(Class Loading)过程的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：

> 1. 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
> 3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

2. **验证**是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

3. **准备阶段**是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

4. **解析阶段**是虚拟机将常量池内的符号引用替换为直接引用的过程。
5. 类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。

##  6. 双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。

1. **启动类加载器**，负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即时放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用。
2. **扩展类加载器**：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该类加载器。
3. **应用程序类加载器**：负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，也是默认的类加载器。 三种加载器的关系：启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器。

这种关系即为类加载器的双亲委派模型。其要求除启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是用组合的方式来复用父类的代码。

双亲委派模型的工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。

实现：在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

## 7. 描述一下 JVM 加载 Class 文件的原理机制 ##

- Java 语言是一种具有动态性的解释型语言，类（Class）只有被加载到 JVM 后才能运行。当运行指定程序时，JVM 会将编译生成 的 .class 文件按照需求和一定的规则加载到内存中，并组织成为 一个完整的 Java 应用程序。 这个加载过程是由类加载器完成， 具体来说，就是由 ClassLoader 和它的子类来实现的。类加载器本身也是一个类，其**实质是把类文件从硬盘读取到内存中。**

- 类的加载方式分为隐式加载和显示加载。 隐式加载指的是程序在使用 new 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM 中。 显示加载指的是通过直接调用 class.forName() 方法来把所需的类加载到 JVM 中。 

- 类加载的主要步骤： 

- ```
  • 装载。根据查找路径找到相应的 class 文件，然后导入。 
  • 链接。链接又可分为 3 个小步： 
  • 检查，检查待加载的 class 文件的正确性。 
  • 准备，给类中的静态变量分配存储空间。 
  • 解析，将符号引用转换为直接引用（这一步可选） 
  • 初始化。对静态变量和静态代码块执行初始化工作。
  ```

## GC root 根

线程的本地变量，静态变量，本地方法栈的变量

## CMS

CMS收集器是**一种以获取最短回收停顿时间为目标**的收集器。CMS收集器是基于**标记-清除算法**实现的，是一种老年代收集器，通常与**ParNew**一起使用。

**CMS的垃圾收集过程分为4步：**

- **初始标记**：需要“**Stop the World**”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。
- **并发标记**：是主要标记过程，这个标记过程是和用户线程并发执行的。
- **重新标记**：需要“**Stop the World**”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。
- **并发清除**：和用户线程并发执行的，基于标记结果来清理对象。

#### 缺点主要包括如下：

- **对CPU资源非常敏感**，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。
- 收集过程中会产生**浮动垃圾**，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction**的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现**Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。
- **标记-清除方式会产生内存碎片**，可以使用参数**-XX：UseCMSCompactAtFullCollection**来控制是否开启内存整理（无法并发，默认是开启的）。参数**-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。

## G1垃圾收集器调优

> G1 垃圾收集器调优的主要目标是避免发生并发模式失败或者疏散失败，一旦发生这些失败就会导致 Full GC。避免 Full GC 的技巧也适用于频繁发生的新生代垃圾收集，这些垃圾收集需要等待扫描根分区完成才能进行。
>
> 其次，调优可以使过程中的停顿时间最小化。下面所列的这些方法都能够避免发生 Full GC。
>
> G1收集器除了并发标记，其余阶段也是要完全暂停用户线程的
>
> （初始标记、并发标记、并发标记、筛选回收）

1. 通过增加总的堆空间大小或者调整老年代、新生代之间的比例来增加老年代空间的
   大小。
2. 增加后台线程的数目（假设我们有足够的 CPU 资源运行这些线程） 。
3. 以更高的频率进行 G1 的后台垃圾收集活动。
4. 在混合式垃圾回收周期中完成更多的垃圾收集工作。

这里有很多的调优可以做，不过 G1 垃圾收集器调优的目标之一是尽量简单。为了达到这个目标，G1 收集器最主要的调优只通过一个标志进行：这个标志跟 Throughput 收集器的标志一致，也是 **-XX:MaxGCPauseMillis=N 。**

## 待解决