# 计算机网络

## TCP和UDP协议的区别

- TCP协议进行数据通信之前需要三次握手建立连接，UDP协议不需要建立连接即可发送数据。
- TCP有确认机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。
- TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。
- 网络包中的TCP头部为20个字节；UDP头部只有8个字节。

## 三次握手和四次挥手

1. 三次握手

   客户端经历了Close->SYN_SENT->ESTABLISHED的状态变化；
   服务端经历了Close->Listen->SYN_RCVD->EATABLISHED的状态变化。

2. 四次挥手

   **客户端经历的状态变化为：**
       ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSE
   **服务端经历的状态变化为：**
       ESTABLISHED->CLOSE_WAIT-> LAST_ACK->CLOSE

### 为什么要三次握手

假如只有前面2次握手，那么服务端来收到SYN并且发出SYN+ACK包之后就会处于工作状态。如果服务端在某一时刻突然收到了一个来自客户端的SYN包，在发出ACK之后，服务端处于工作状态。但是可能这个包是卡了很久已经被客户端给丢弃了。客户端收到SYN+ACK之后，表示情绪淡定不予理会，但是服务端已经处于工作状态了，会造成资源的浪费。

### 为什么要四次挥手

根据状态流程图，我们可以看出服务端响应断开连接的请求时，其ACK和FIN包并不是一起发送给客户端的，因为第一次由客户端->服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。

### 四次挥手主动方为什么需要等待2MSL

主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。我们先来解释下什么叫MSL（Maximum Segment Lifetime）吧。

**MSL表示最大报文生存周期**，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

主动关闭方需要等待2MSL是为了，防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号。

## HTTP和HTTPS的区别有哪些

- HTTP是超文本传输协议，数据明文传输；HTTPS在HTTP的基础上加入了SSL协议，实现数据的加密传输；
- HTTPS需要区申请证书，一般是收费的；
- HTTP默认使用80端口，HTTPS默认使用443端口

## HTTP请求中的Get和Post方法有哪些区别

- Get一般用来从服务器上查询获取资源；Post一般用来更新服务器上的资源；
- Get方法将参数直接拼接在了URL后边，明文显示，可以通过浏览器地址栏直接访问；
- Post请求用于提交表单，数据不是明文的，安全性更高；
- Get请求有长度限制，Post请求没有

## 常见的HTTP Code有哪些

- 1xx（临时响应）
- 2xx（成功）
- 3xx（重定向）：表示要完成请求需要进一步操作
- 4xx（错误）：表示请求可能出错，妨碍了服务器的处理
- 5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误

## cookie和session有了解吗

**HTTP协议是一种无状态的协议，我们可以使用cookie和session来保持会话状态**。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。

## http1 2 3的区别具体说一下

> https://network.51cto.com/art/202003/612101.htm
>
> HTTP/1.1有两个主要的缺点：安全不足和性能不高。
>
> HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；
>
> QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。

- **HTTP1.0：**

HTTP1.0是一种无状态，无连接的协议。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。也就是默认使用Connection: close

- **HTTP1.1：**

HTTP/1.1中默认使用Connection: keep-alive，避免了连接建立和释放的开销。但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。

- **HTTP2.0：**

HTTP2.0协议新增了二进制分帧，多路复用，头部压缩和服务器推送等功能，进一步提高了传输效率。

## ARP地址解析协议

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
5. 广播发送ARP请求，单播发送ARP响应。

## 路由汇聚

## 子网掩码的求法